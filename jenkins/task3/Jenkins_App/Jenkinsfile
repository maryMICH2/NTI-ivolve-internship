pipeline {
    agent any

    environment {
        // --- Application Path ---
        // Path relative to the workspace root where the source code and Dockerfile are located.
        APP_DIR = 'jenkins/task3/Jenkins_App/src/main/java/com/example
/demo/DemoApplication.java'

        // --- Credentials and File Paths ---
        DOCKER_CREDENTIALS_ID = 'Docker-Hub-Credentials'
        KUBE_CONFIG_CREDENTIAL_ID = 'jenkins-sa-credential'
        // The deployment.yaml path is relative to the workspace root.
        DEPLOYMENT_FILE = "${env.APP_DIR}/k8s/deployment.yaml" 

        // --- Dynamic Image Tagging ---
        DOCKER_USER_IMAGE = 'maaryii/test-image' 
        NEW_IMAGE_TAG = "build-${env.BUILD_NUMBER}"
        FULL_DOCKER_IMAGE = "${env.DOCKER_USER_IMAGE}:${env.NEW_IMAGE_TAG}"
    }

    stages {
        // Stage 1: Run Unit Test - Executed inside the application directory
        stage('Run Unit Tests') {
            steps {
                dir(env.APP_DIR) { 
                    sh 'npm install'
                    sh 'npm test'
                }
            }
        }

        // Stage 2: Build App - Executed inside the application directory
        stage('Build App') {
            steps {
                dir(env.APP_DIR) {
                    // Placeholder for the application build command (e.g., if needed for production builds)
                    echo 'Application build step executed.' 
                }
            }
        }

        // Stage 3: Build Docker image from Dockerfile
        stage('Build Docker Image') {
            steps {
                script {
                    // Use the application directory as the build context.
                    // The Dockerfile path is relative to the context (which is the workspace root).
                    docker.build(env.FULL_DOCKER_IMAGE, "-f ${env.APP_DIR}/Dockerfile ${env.APP_DIR}")
                }
            }
        }

        // Stage 4: Push image to Docker hub
        stage('Push Docker Image') {
            steps {
                withCredentials([usernamePassword(credentialsId: env.DOCKER_CREDENTIALS_ID,
                                                 usernameVariable: 'DOCKER_USER',
                                                 passwordVariable: 'DOCKER_PASS')]) {
                    sh """
                        echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin
                        docker push ${env.FULL_DOCKER_IMAGE}
                    """
                }
            }
        }
        
        // Stage 5: Delete image locally
        stage('Delete Image Locally') {
            steps {
                sh "docker rmi ${env.FULL_DOCKER_IMAGE}"
            }
        }

        // Stage 6: Edit new image in deployment.yaml file
        stage('Update Deployment Image') {
            steps {
                sh """
                    # Use sed to replace the old image tag with the new, unique tag
                    # The DEPLOYMENT_FILE variable now includes the full path.
                    sed -i "s|image: ${env.DOCKER_USER_IMAGE}:.*|image: ${env.FULL_DOCKER_IMAGE}|g" ${env.DEPLOYMENT_FILE}
                    echo "Updated image in ${env.DEPLOYMENT_FILE} to ${env.FULL_DOCKER_IMAGE}"
                """
            }
        }

        // Stage 7: Deploy to k8s cluster
        stage('Deploy to Kubernetes') {
            steps {
                withCredentials([file(credentialsId: env.KUBE_CONFIG_CREDENTIAL_ID, variable: 'KUBECONFIG_FILE')]) {
                    sh """
                        export KUBECONFIG=$KUBECONFIG_FILE
                        kubectl apply -f ${env.DEPLOYMENT_FILE}
                    """
                }
            }
        }
    }

    // Post Actions
    post {
        always {
            echo 'Pipeline completed. Finalizing run details.'
        }
        success {
            echo '✅ Deployment Pipeline SUCCEEDED.'
        }
        failure {
            echo '❌ Deployment Pipeline FAILED. Review logs for errors.'
        }
    }
}
